<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Space Game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
    }
    @font-face {
      font-family: 'Gothic';
      src: local('Century Gothic'), local('Arial Black'), sans-serif;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: 'Gothic', sans-serif;
      font-size: 28px;
      font-weight: bold;
      z-index: 10;
      text-shadow: 2px 2px 4px black;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud">Leben: <span id="lives">3</span> | Score: <span id="score">0</span></div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let mouse = { x: canvas.width / 2, y: canvas.height / 2 };
let keys = {};
let lives = 3;
let score = 0;
let powerUps = [];

document.getElementById("lives").textContent = lives;
document.getElementById("score").textContent = score;

let stars = [];
for (let i = 0; i < 150; i++) {
  stars.push({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    size: Math.random() * 2,
    speed: Math.random() * 0.5 + 0.2,
  });
}

class Ship {
  constructor() {
    this.x = canvas.width / 2;
    this.y = canvas.height / 2;
    this.angle = 0;
    this.vel = { x: 0, y: 0 };
    this.radius = 20;
    this.doubleShot = false;
    this.doubleTimer = 0;
  }

  update() {
    this.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
    if (keys["w"]) {
      this.vel.x += Math.cos(this.angle) * 0.2;
      this.vel.y += Math.sin(this.angle) * 0.2;
    }
    this.vel.x *= 0.92;
    this.vel.y *= 0.92;
    this.x += this.vel.x;
    this.y += this.vel.y;

    for (let star of stars) {
      star.x -= this.vel.x * star.speed;
      star.y -= this.vel.y * star.speed;
      if (star.x < 0) star.x += canvas.width;
      if (star.x > canvas.width) star.x -= canvas.width;
      if (star.y < 0) star.y += canvas.height;
      if (star.y > canvas.height) star.y -= canvas.height;
    }

    if (this.x < 0) this.x = canvas.width;
    if (this.x > canvas.width) this.x = 0;
    if (this.y < 0) this.y = canvas.height;
    if (this.y > canvas.height) this.y = 0;

    if (this.doubleShot && this.doubleTimer > 0) {
      this.doubleTimer--;
    } else {
      this.doubleShot = false;
    }
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    if (keys["w"]) {
      for (let i = 0; i < 3; i++) {
        const flicker = Math.random() * 10 + 10;
        const offset = (Math.random() - 0.5) * 4;
        ctx.beginPath();
        ctx.moveTo(-15, offset - 4);
        ctx.lineTo(-15 - flicker, 0);
        ctx.lineTo(-15, offset + 4);
        ctx.fillStyle = `hsl(${Math.random() * 30 + 20}, 100%, 50%)`;
        ctx.fill();
      }
    }
    ctx.fillStyle = "#00ffff";
    ctx.beginPath();
    ctx.moveTo(20, 0);
    ctx.lineTo(-15, -12);
    ctx.lineTo(-10, 0);
    ctx.lineTo(-15, 12);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
}

class Bullet {
  constructor(x, y, angle) {
    this.x = x;
    this.y = y;
    this.angle = angle;
    this.vel = {
      x: Math.cos(angle) * 12,
      y: Math.sin(angle) * 12,
    };
    this.length = 18;
  }

  update() {
    this.x += this.vel.x;
    this.y += this.vel.y;
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    ctx.strokeStyle = "red";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(this.length, 0);
    ctx.stroke();
    ctx.restore();
  }

  offscreen() {
    return (
      this.x < -50 || this.x > canvas.width + 50 ||
      this.y < -50 || this.y > canvas.height + 50
    );
  }
}

class Enemy {
  constructor() {
    const edge = Math.floor(Math.random() * 4);
    if (edge === 0) {
      this.x = Math.random() * canvas.width;
      this.y = -30;
    } else if (edge === 1) {
      this.x = canvas.width + 30;
      this.y = Math.random() * canvas.height;
    } else if (edge === 2) {
      this.x = Math.random() * canvas.width;
      this.y = canvas.height + 30;
    } else {
      this.x = -30;
      this.y = Math.random() * canvas.height;
    }
    this.radius = 20;
    this.speed = 1.2;
    this.angle = 0;
  }

  update(target) {
    this.angle = Math.atan2(target.y - this.y, target.x - this.x);
    this.x += Math.cos(this.angle) * this.speed;
    this.y += Math.sin(this.angle) * this.speed;
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.moveTo(0, -20);
    ctx.lineTo(15, 15);
    ctx.lineTo(-15, 15);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
}

class PowerUp {
  constructor(type) {
    this.x = Math.random() * canvas.width;
    this.y = Math.random() * canvas.height;
    this.type = type;
    this.radius = 20;
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    if (this.type === "life") {
      ctx.fillStyle = "lime";
      ctx.beginPath();
      ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "white";
      ctx.font = "16px monospace";
      ctx.textAlign = "center";
      ctx.fillText("+", 0, 6);
    } else {
      ctx.fillStyle = "gold";
      ctx.beginPath();
      ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "black";
      ctx.font = "14px monospace";
      ctx.textAlign = "center";
      ctx.fillText("2x", 0, 6);
    }
    ctx.restore();
  }
}

const ship = new Ship();
const bullets = [];
const enemies = [];

let spawnTimer = 0;
let powerTimer = 0;
let enemySpawnRate = 120;
let gameFrame = 0;

function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "white";
  for (let star of stars) {
    ctx.fillRect(star.x, star.y, star.size, star.size);
  }

  ship.update();
  ship.draw();

  gameFrame++;
  if (spawnTimer >= enemySpawnRate) {
    enemies.push(new Enemy());
    spawnTimer = 0;
    if (enemySpawnRate > 30) enemySpawnRate -= 1;
  } else {
    spawnTimer++;
  }

  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    e.update(ship);
    e.draw();
    const dx = e.x - ship.x;
    const dy = e.y - ship.y;
    const dist = Math.hypot(dx, dy);
    if (dist < e.radius + ship.radius) {
      enemies.splice(i, 1);
      lives--;
      document.getElementById("lives").textContent = lives;
      if (lives <= 0) {
        alert("Game Over\nFinaler Score: " + score);
        window.location.reload();
      }
      continue;
    }

    for (let j = bullets.length - 1; j >= 0; j--) {
      const b = bullets[j];
      const bdx = e.x - b.x;
      const bdy = e.y - b.y;
      if (Math.hypot(bdx, bdy) < e.radius) {
        enemies.splice(i, 1);
        bullets.splice(j, 1);
        score++;
        document.getElementById("score").textContent = score;
        break;
      }
    }
  }

  powerTimer++;
  if (powerTimer > 600) {
    const type = Math.random() < 0.5 ? "life" : "double";
    powerUps.push(new PowerUp(type));
    powerTimer = 0;
  }

  for (let i = powerUps.length - 1; i >= 0; i--) {
    const p = powerUps[i];
    p.draw();
    const dx = p.x - ship.x;
    const dy = p.y - ship.y;
    if (Math.hypot(dx, dy) < p.radius + ship.radius) {
      if (p.type === "life") {
        lives++;
        document.getElementById("lives").textContent = lives;
      } else if (p.type === "double") {
        ship.doubleShot = true;
        ship.doubleTimer = 600;
      }
      powerUps.splice(i, 1);
    }
  }

  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.update();
    b.draw();
    if (b.offscreen()) {
      bullets.splice(i, 1);
    }
  }

  requestAnimationFrame(gameLoop);
}

gameLoop();

document.addEventListener("mousemove", e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
});

document.addEventListener("keydown", e => {
  keys[e.key.toLowerCase()] = true;
});

document.addEventListener("keyup", e => {
  keys[e.key.toLowerCase()] = false;
});

document.addEventListener("mousedown", e => {
  if (e.button === 0) {
    bullets.push(new Bullet(ship.x, ship.y, ship.angle));
    if (ship.doubleShot) {
      bullets.push(new Bullet(ship.x, ship.y, ship.angle + 0.1));
      bullets.push(new Bullet(ship.x, ship.y, ship.angle - 0.1));
    }
  }
});
</script>
</body>
</html>

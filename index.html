<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Space Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      touch-action: manipulation; /* Verhindert das Standard-Touch-Verhalten */
      height: 100%; /* Sicherstellen, dass body die volle Höhe einnimmt */
      width: 100%;
    }
    canvas {
      display: block;
    }
    @font-face {
      font-family: 'Gothic';
      src: local('Century Gothic'), local('Arial Black'), sans-serif;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: 'Gothic', sans-serif;
      font-size: 28px;
      font-weight: bold;
      z-index: 10;
      text-shadow: 2px 2px 4px black;
    }

    /* Mobile Controls Container */
    #mobile-controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      right: 20px;
      display: flex; /* Flexbox für Anordnung */
      justify-content: space-between; /* Abstand zwischen Joystick und Button */
      align-items: flex-end;
      width: calc(100% - 40px);
      z-index: 20;
    }

    /* Joystick Container */
    #joystick-container {
      position: relative; /* Wichtig für die absolute Positionierung des Joysticks */
      width: 150px;
      height: 150px;
      background-color: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      display: flex; /* Für Zentrierung des Joysticks beim Reset */
      justify-content: center;
      align-items: center;
      flex-shrink: 0; /* Verhindert Schrumpfen in Flexbox */
    }

    /* Joystick Ball */
    #joystick {
      width: 80px;
      height: 80px;
      background-color: rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      position: absolute; /* Absolut innerhalb des Containers */
      touch-action: none; /* Verhindert Scrolling beim Ziehen */
      left: calc(50% - 40px); /* Zentrieren innerhalb des Containers */
      top: calc(50% - 40px);  /* Zentrieren innerhalb des Containers */
    }

    /* Shoot Button */
    #shoot-button {
      width: 100px;
      height: 100px;
      background-color: rgba(255, 0, 0, 0.6);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-family: 'Gothic', sans-serif;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 1px 1px 2px black;
      user-select: none; /* Verhindert Textauswahl */
      flex-shrink: 0;
      margin-left: 20px; /* Abstand zum Joystick */
    }

    /* Game Over Screen */
    #game-over-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      font-family: 'Gothic', sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-size: 4em;
      text-shadow: 4px 4px 8px black;
      z-index: 100;
      display: none; /* Standardmäßig ausgeblendet */
    }
    #game-over-screen button {
      margin-top: 30px;
      padding: 15px 30px;
      font-size: 1.2em;
      font-family: 'Gothic', sans-serif;
      background-color: #00ffff;
      color: black;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
      transition: background-color 0.2s, transform 0.2s;
    }
    #game-over-screen button:hover {
      background-color: #00cccc;
      transform: scale(1.05);
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud">Leben: <span id="lives">3</span> | Score: <span id="score">0</span> | Schild: <span id="shield-time">0</span></div>

<div id="mobile-controls">
  <div id="joystick-container">
    <div id="joystick"></div>
  </div>
  <div id="shoot-button">FEUER</div>
</div>

<div id="game-over-screen">
  <div>GAME OVER</div>
  <div style="font-size: 0.5em; margin-top: 10px;">Dein Score: <span id="final-score">0</span></div>
  <button id="restart-button">Nochmal spielen</button>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// Globale Variablen
let mouse = { x: 0, y: 0 }; // Initialisierung auf 0,0
let keys = {};
let lives = 3;
let score = 0;
let powerUps = [];
let particles = [];
let shieldActive = false;
let shieldTimer = 0;
let gameRunning = true;
let animationFrameId; // Zum Speichern der Request-Animation-Frame ID

const isMobile = /Mobi|Android/i.test(navigator.userAgent);

// HUD- und Screen-Elemente
const livesSpan = document.getElementById("lives");
const scoreSpan = document.getElementById("score");
const shieldTimeSpan = document.getElementById("shield-time");
const gameOverScreen = document.getElementById("game-over-screen");
const finalScoreSpan = document.getElementById("final-score");
const restartButton = document.getElementById("restart-button");
const mobileControlsDiv = document.getElementById("mobile-controls");

// Mobile Joystick und Schuss-Button Elemente
const joystickContainer = document.getElementById("joystick-container");
const joystick = document.getElementById("joystick");
const shootButton = document.getElementById("shoot-button");

// --- CANVAS UND RESPONSIVITÄT ---
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  // Schiff nach Größenänderung mittig platzieren
  if (ship) {
    ship.x = canvas.width / 2;
    ship.y = canvas.height / 2;
    // Mausposition auf Schiffsmitte setzen, wenn PC
    if (!isMobile) {
      mouse.x = ship.x;
      mouse.y = ship.y;
    }
  }
  // Sterne neu generieren, damit sie sich an die neue Größe anpassen
  createStars();
}
window.addEventListener('resize', resizeCanvas);


// --- STERNEN-GENERIERUNG ---
let stars = [];
function createStars() {
  stars = []; // Alte Sterne löschen
  for (let i = 0; i < 150; i++) {
    stars.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      size: Math.random() * 2,
      speed: Math.random() * 0.5 + 0.2,
    });
  }
}

// --- KLASSEN DEFINITIONEN ---

class Ship {
  constructor() {
    this.x = canvas.width / 2;
    this.y = canvas.height / 2;
    this.angle = 0;
    this.vel = { x: 0, y: 0 };
    this.radius = 20;
    this.doubleShot = false;
    this.doubleTimer = 0;
  }

  update() {
    if (!gameRunning) return; // Schiff bewegt sich nicht, wenn Spiel vorbei

    let thrusting = false;

    if (!isMobile) {
      // PC-Steuerung: Maus für Winkel, 'W' für Schub
      this.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
      if (keys["w"]) {
        this.vel.x += Math.cos(this.angle) * 0.2;
        this.vel.y += Math.sin(this.angle) * 0.2;
        thrusting = true;
      }
    } else {
      // Mobile Steuerung: Joystick für Winkel und Schub
      const joystickContainerRect = joystickContainer.getBoundingClientRect();
      const joystickRect = joystick.getBoundingClientRect();

      // Umwandlung der absoluten Bildschirmkoordinaten in relative Canvas-Koordinaten
      // Da Joystick-Container immer am selben Bildschirmrand ist, kann man hier auch offsets benutzen
      const joystickCenterX = joystickContainerRect.left + joystickContainerRect.width / 2;
      const joystickCenterY = joystickContainerRect.top + joystickContainerRect.height / 2;
      
      const currentJoystickX = joystickRect.left + joystickRect.width / 2;
      const currentJoystickY = joystickRect.top + joystickRect.height / 2;

      const dxJoy = currentJoystickX - joystickCenterX;
      const dyJoy = currentJoystickY - joystickCenterY;

      // Kleiner Schwellenwert, um "Zittern" zu vermeiden, wenn der Joystick nicht bewegt wird
      if (Math.hypot(dxJoy, dyJoy) > 10) { 
          this.angle = Math.atan2(dyJoy, dxJoy);
          this.vel.x += Math.cos(this.angle) * 0.2;
          this.vel.y += Math.sin(this.angle) * 0.2;
          thrusting = true;
      }
    }

    this.vel.x *= 0.92; // Reibung
    this.vel.y *= 0.92;
    this.x += this.vel.x;
    this.y += this.vel.y;

    // Partikel für den Feuerschweif erzeugen
    if (thrusting) {
      for (let i = 0; i < 2; i++) {
        const offsetAngle = this.angle + Math.PI + (Math.random() - 0.5) * 0.6; // Hinter dem Schiff
        const speed = Math.random() * 3 + 1;
        particles.push(new Particle(this.x - Math.cos(this.angle) * 15, this.y - Math.sin(this.angle) * 15, offsetAngle, speed));
      }
    }

    // Wrap-around für Sterne (Parallaxen-Effekt)
    for (let star of stars) {
      star.x -= this.vel.x * star.speed;
      star.y -= this.vel.y * star.speed;
      if (star.x < 0) star.x += canvas.width;
      if (star.x > canvas.width) star.x -= canvas.width;
      if (star.y < 0) star.y += canvas.height;
      if (star.y > canvas.height) star.y -= canvas.height;
    }

    // Wrap-around für Schiff
    if (this.x < 0) this.x = canvas.width;
    if (this.x > canvas.width) this.x = 0;
    if (this.y < 0) this.y = canvas.height;
    if (this.y > canvas.height) this.y = 0;

    // Double Shot Timer
    if (this.doubleShot && this.doubleTimer > 0) {
      this.doubleTimer--;
    } else {
      this.doubleShot = false;
    }

    // Schild Timer
    if (shieldActive && shieldTimer > 0) {
        shieldTimer--;
        shieldTimeSpan.textContent = Math.ceil(shieldTimer / 60); // In Sekunden anzeigen (60 Frames pro Sekunde)
    } else {
        shieldActive = false;
        shieldTimeSpan.textContent = 0;
    }
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    
    // Thruster-Flammen nur zeichnen, wenn beschleunigt wird
    let thrusting = false;
    if (!isMobile && keys["w"]) thrusting = true;
    if (isMobile) {
      // Ermittle, ob der Joystick bewegt wird (Schub gegeben wird)
      const joystickContainerRect = joystickContainer.getBoundingClientRect();
      const joystickRect = joystick.getBoundingClientRect();
      const joystickCenterX = joystickContainerRect.left + joystickContainerRect.width / 2;
      const joystickCenterY = joystickContainerRect.top + joystickContainerRect.height / 2;
      const currentJoystickX = joystickRect.left + joystickRect.width / 2;
      const currentJoystickY = joystickRect.top + joystickRect.height / 2;
      if (Math.hypot(currentJoystickX - joystickCenterX, currentJoystickY - joystickCenterY) > 10) {
          thrusting = true;
      }
    }

    if (thrusting) {
      for (let i = 0; i < 3; i++) {
        const flicker = Math.random() * 10 + 10;
        const offset = (Math.random() - 0.5) * 4;
        ctx.beginPath();
        ctx.moveTo(-15, offset - 4);
        ctx.lineTo(-15 - flicker, 0);
        ctx.lineTo(-15, offset + 4);
        ctx.fillStyle = `hsl(${Math.random() * 30 + 20}, 100%, 50%)`;
        ctx.fill();
      }
    }
    
    // Schiff zeichnen
    ctx.fillStyle = "#00ffff";
    ctx.beginPath();
    ctx.moveTo(20, 0);
    ctx.lineTo(-15, -12);
    ctx.lineTo(-10, 0);
    ctx.lineTo(-15, 12);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // Schild zeichnen, wenn aktiv
    if (shieldActive) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius + 10, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(0, 200, 255, 0.7)";
      ctx.lineWidth = 3;
      ctx.stroke();
    }
  }
}

class Particle {
    constructor(x, y, angle, speed) {
        this.x = x;
        this.y = y;
        this.velX = Math.cos(angle) * speed;
        this.velY = Math.sin(angle) * speed;
        this.alpha = 1;
        this.size = Math.random() * 5 + 2;
        this.color = `hsl(${Math.random() * 30 + 10}, 100%, 50%)`;
    }

    update() {
        this.x += this.velX;
        this.y += this.velY;
        this.alpha -= 0.02; // Partikel verblassen lassen
        this.size *= 0.95; // Partikel schrumpfen lassen
    }

    draw() {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

class Bullet {
  constructor(x, y, angle) {
    this.x = x;
    this.y = y;
    this.angle = angle;
    this.vel = {
      x: Math.cos(angle) * 12,
      y: Math.sin(angle) * 12,
    };
    this.length = 18;
  }

  update() {
    this.x += this.vel.x;
    this.y += this.vel.y;
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    ctx.strokeStyle = "red";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(this.length, 0);
    ctx.stroke();
    ctx.restore();
  }

  offscreen() {
    return (
      this.x < -50 || this.x > canvas.width + 50 ||
      this.y < -50 || this.y > canvas.height + 50
    );
  }
}

class Enemy {
  constructor() {
    // Spawnt Gegner immer außerhalb des Bildschirms, mit etwas Puffer
    const edge = Math.floor(Math.random() * 4);
    if (edge === 0) { // Oben
      this.x = Math.random() * canvas.width;
      this.y = -50;
    } else if (edge === 1) { // Rechts
      this.x = canvas.width + 50;
      this.y = Math.random() * canvas.height;
    } else if (edge === 2) { // Unten
      this.x = Math.random() * canvas.width;
      this.y = canvas.height + 50;
    } else { // Links
      this.x = -50;
      this.y = Math.random() * canvas.height;
    }
    this.radius = 20;
    this.speed = 1.2;
    this.angle = 0;
  }

  update(target) {
    // Gegner schaut IMMER direkt zum Spieler
    this.angle = Math.atan2(target.y - this.y, target.x - this.x);

    this.x += Math.cos(this.angle) * this.speed;
    this.y += Math.sin(this.angle) * this.speed;
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.moveTo(0, -20);
    ctx.lineTo(15, 15);
    ctx.lineTo(-15, 15);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
}

class PowerUp {
  constructor(type) {
    this.x = Math.random() * canvas.width;
    this.y = Math.random() * canvas.height;
    this.type = type;
    this.radius = 20;
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    if (this.type === "life") {
      ctx.fillStyle = "lime";
      ctx.beginPath();
      ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "white";
      ctx.font = "16px monospace";
      ctx.textAlign = "center";
      ctx.fillText("+", 0, 6);
    } else if (this.type === "double") {
      ctx.fillStyle = "gold";
      ctx.beginPath();
      ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "black";
      ctx.font = "14px monospace";
      ctx.textAlign = "center";
      ctx.fillText("2x", 0, 6);
    } else if (this.type === "shield") {
      ctx.fillStyle = "blue";
      ctx.beginPath();
      ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "white";
      ctx.font = "16px monospace";
      ctx.textAlign = "center";
      ctx.fillText("S", 0, 6);
    }
    ctx.restore();
  }
}

// --- SPIEL OBJEKTE ---
const ship = new Ship();
const bullets = [];
const enemies = [];


// --- SPIEL LOOP UND LOGIK ---
let spawnTimer = 0;
let powerTimer = 0;
let enemySpawnRate = 120; // Startrate der Gegner

function initGame() {
  // Spielzustand zurücksetzen
  lives = 3;
  score = 0;
  shieldActive = false;
  shieldTimer = 0;
  enemySpawnRate = 120; // Schwierigkeitsgrad zurücksetzen
  gameRunning = true;

  // HUD aktualisieren
  livesSpan.textContent = lives;
  scoreSpan.textContent = score;
  shieldTimeSpan.textContent = shieldTimer;
  gameOverScreen.style.display = "none"; // Game Over Screen ausblenden

  // Spiellogik-Arrays leeren
  bullets.length = 0;
  enemies.length = 0;
  powerUps.length = 0;
  particles.length = 0;

  // Schiff in die Mitte setzen
  ship.x = canvas.width / 2;
  ship.y = canvas.height / 2;
  ship.vel.x = 0;
  ship.vel.y = 0;
  ship.doubleShot = false;
  ship.doubleTimer = 0;

  // Mausposition auf Schiffsmitte setzen (für PC)
  if (!isMobile) {
    mouse.x = ship.x;
    mouse.y = ship.y;
  }

  createStars(); // Sterne neu anordnen

  // Sicherstellen, dass nur eine gameLoop läuft
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId);
  }
  animationFrameId = requestAnimationFrame(gameLoop);
}

function gameOver() {
  gameRunning = false;
  cancelAnimationFrame(animationFrameId); // Stoppt die Spiel-Loop
  finalScoreSpan.textContent = score; // Finalen Score setzen
  gameOverScreen.style.display = "flex"; // Zeigt den Game Over Screen an
}

function gameLoop() {
  if (!gameRunning) return; // Stoppt die Loop, wenn das Spiel vorbei ist

  ctx.clearRect(0, 0, canvas.width, canvas.height); // Canvas leeren
  
  // Hintergrund Sterne zeichnen
  ctx.fillStyle = "white";
  for (let star of stars) {
    ctx.fillRect(star.x, star.y, star.size, star.size);
  }

  // Partikel aktualisieren und zeichnen (für Feuerschweif)
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.update();
    p.draw();
    if (p.alpha <= 0.05 || p.size <= 0.5) {
      particles.splice(i, 1);
    }
  }

  // Schiff aktualisieren und zeichnen
  ship.update();
  ship.draw();

  // Gegner Spawning
  if (spawnTimer >= enemySpawnRate) {
    enemies.push(new Enemy());
    spawnTimer = 0;
    if (enemySpawnRate > 30) enemySpawnRate -= 1; // Gegner spawnen schneller, Schwierigkeit erhöht
  } else {
    spawnTimer++;
  }

  // Gegner aktualisieren, zeichnen und Kollision mit Spieler prüfen
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    e.update(ship);
    e.draw();
    
    // Kollision mit Schiff
    const dx = e.x - ship.x;
    const dy = e.y - ship.y;
    const dist = Math.hypot(dx, dy);
    if (dist < e.radius + ship.radius) {
      if (shieldActive) {
        enemies.splice(i, 1); // Gegner wird zerstört, wenn Schild aktiv ist
      } else {
        enemies.splice(i, 1);
        lives--;
        livesSpan.textContent = lives;
        if (lives <= 0) {
          gameOver();
          return; // Beende diese Frame, um den Game Over Screen anzuzeigen und weitere Kollisionen zu verhindern
        }
      }
      continue; // Gehe zum nächsten Gegner, wenn dieser bereits kollidiert ist
    }

    // Kollision mit Kugeln
    for (let j = bullets.length - 1; j >= 0; j--) {
      const b = bullets[j];
      const bdx = e.x - b.x;
      const bdy = e.y - b.y;
      if (Math.hypot(bdx, bdy) < e.radius) { // Treffer!
        enemies.splice(i, 1);
        bullets.splice(j, 1);
        score++;
        scoreSpan.textContent = score;
        break; // Nur eine Kugel kann einen Gegner treffen
      }
    }
  }

  // Power-Up Spawning
  powerTimer++;
  if (powerTimer > 600) { // Alle 10 Sekunden ein Power-Up
    const types = ["life", "double", "shield"];
    const type = types[Math.floor(Math.random() * types.length)];
    powerUps.push(new PowerUp(type));
    powerTimer = 0;
  }

  // Power-Ups aktualisieren, zeichnen und Kollision mit Spieler prüfen
  for (let i = powerUps.length - 1; i >= 0; i--) {
    const p = powerUps[i];
    p.draw();
    const dx = p.x - ship.x;
    const dy = p.y - ship.y;
    if (Math.hypot(dx, dy) < p.radius + ship.radius) { // Power-Up eingesammelt
      if (p.type === "life") {
        lives++;
        livesSpan.textContent = lives;
      } else if (p.type === "double") {
        ship.doubleShot = true;
        ship.doubleTimer = 600; // 10 Sekunden Double Shot
      } else if (p.type === "shield") {
        shieldActive = true;
        shieldTimer = 600; // 10 Sekunden Schild
        shieldTimeSpan.textContent = Math.ceil(shieldTimer / 60);
      }
      powerUps.splice(i, 1); // Power-Up entfernen
    }
  }

  // Kugeln aktualisieren, zeichnen und außerhalb des Bildschirms entfernen
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.update();
    b.draw();
    if (b.offscreen()) {
      bullets.splice(i, 1);
    }
  }

  animationFrameId = requestAnimationFrame(gameLoop);
}

// --- STEUERUNGS EVENTS ---

// Funktion zum Abfeuern von Kugeln
function fireBullet() {
    bullets.push(new Bullet(ship.x, ship.y, ship.angle));
    if (ship.doubleShot) {
      bullets.push(new Bullet(ship.x, ship.y, ship.angle + 0.1));
      bullets.push(new Bullet(ship.x, ship.y, ship.angle - 0.1));
    }
}

// PC-Steuerung Events
document.addEventListener("mousemove", e => {
  if (!isMobile && gameRunning) {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
  }
});

document.addEventListener("keydown", e => {
  if (!isMobile && gameRunning) {
    keys[e.key.toLowerCase()] = true;
  }
});

document.addEventListener("keyup", e => {
  if (!isMobile && gameRunning) {
    keys[e.key.toLowerCase()] = false;
  }
});

document.addEventListener("mousedown", e => {
  if (!isMobile && e.button === 0 && gameRunning) {
    fireBullet();
  }
});

// Mobile Joystick und Schuss-Button Events
let isDragging = false;
let startTouchX, startTouchY;
let initialJoystickLeft, initialJoystickTop; // Relative Startposition des Joysticks im Container

if (isMobile) {
  // Mobile Controls anzeigen
  mobileControlsDiv.style.display = "flex";

  joystick.addEventListener("touchstart", (e) => {
    if (!gameRunning) return;
    e.preventDefault(); // Verhindert Standard-Touch-Verhalten
    isDragging = true;
    startTouchX = e.touches[0].clientX;
    startTouchY = e.touches[0].clientY;
    
    // Ermittle die aktuelle Position des Joysticks relativ zum Container
    const joystickRect = joystick.getBoundingClientRect();
    const containerRect = joystickContainer.getBoundingClientRect();
    initialJoystickLeft = joystickRect.left - containerRect.left;
    initialJoystickTop = joystickRect.top - containerRect.top;
  }, { passive: false }); // passive: false ist wichtig für preventDefault

  document.addEventListener("touchmove", (e) => {
    if (!isDragging || !gameRunning) return;
    e.preventDefault(); // Verhindert Scrolling der Seite beim Ziehen

    const currentTouchX = e.touches[0].clientX;
    const currentTouchY = e.touches[0].clientY;

    let deltaX = currentTouchX - startTouchX;
    let deltaY = currentTouchY - startTouchY;

    const containerRect = joystickContainer.getBoundingClientRect();
    const joystickWidth = joystick.clientWidth;
    const joystickHeight = joystick.clientHeight;

    const maxDelta = (containerRect.width / 2) - (joystickWidth / 2);

    // Begrenze deltaX und deltaY innerhalb des Kreises des Containers
    const distance = Math.hypot(deltaX, deltaY);
    if (distance > maxDelta) {
      const angle = Math.atan2(deltaY, deltaX);
      deltaX = Math.cos(angle) * maxDelta;
      deltaY = Math.sin(angle) * maxDelta;
    }

    // Setze die neue Position des Joysticks relativ zum Container
    joystick.style.left = `${initialJoystickLeft + deltaX}px`;
    joystick.style.top = `${initialJoystickTop + deltaY}px`;
  }, { passive: false });

  document.addEventListener("touchend", () => {
    isDragging = false;
    // Joystick in die Mitte zurücksetzen (CSS-zentrierte Position verwenden)
    joystick.style.left = `calc(50% - ${joystick.clientWidth / 2}px)`;
    joystick.style.top = `calc(50% - ${joystick.clientHeight / 2}px)`;
  });

  shootButton.addEventListener("touchstart", (e) => {
    if (!gameRunning) return;
    e.preventDefault(); // Verhindert Standard-Touch-Verhalten
    fireBullet();
  }, { passive: false });
} else {
  // Mobile Controls auf PC ausblenden
  mobileControlsDiv.style.display = "none";
}

// Event Listener für den Restart-Button
restartButton.addEventListener("click", initGame);

// --- SPIEL START ---
// Initialisiert das Canvas und das Spiel beim ersten Laden
resizeCanvas(); // Erstmalige Anpassung der Canvas-Größe und Schiffs-Position
initGame(); // Spiel starten

</script>
</body>
</html>
